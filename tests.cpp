/*
	Type Handle to Avoid Implicit Conversions in standard C++

	Copyright 2019 Dušan B. Jovanović (dbj@dbj.org)

	Please see the LICENCE file
*/


#include <array>
#include <vector>
#include <iostream>
#include <cassert>
#include <type_traits>

// we use C++ streams just in this short testing code
#define DBJ_NOTHING_BUT_STREAMS
#include "dbj_nothing_but.h"

/*
 By "testing" in this context we basically mean: "does it or does it not compile"
 So we do not use any "testing framework"

 Compatibility: This is built with Microsoft (R) C/C++ Optimizing Compiler Version 19.21.27702.2 for x86

 NOTE: Default warning level is "LEVEL 3" aka /W3

 Project settings are completely kept default as generated by Visual Studio 2019
*/

void test_different_types();
void test_try_to_trick();
void test_assignments();
void test_compatibility();

#pragma warning( push )
#pragma warning( disable : 4101 )
// warning C4101 : unused local variable


/*
-----------------------------------------------------------------------------
utils
*/

// Show eXpression
#define SX(x) std::cout << std::boolalpha <<  "\n Expression: " << (#x) \
<< "\n\t Value: " << (x) << "\n"


namespace dbj {

	template<typename T>
	using remove_cvr_t = typename std::remove_reference_t< std::remove_cv_t<T> >;
} // dbj
/**/
inline auto mover = [](auto arg_) noexcept
{
	return arg_;
};

// safe computing in action
// Safe SiZE
using safe_size = dbj::util::nothing_but< size_t >;
// Safe u char
using unsigned_char_type  = dbj::util::nothing_but < unsigned char >;
// safe u char buffer
using uc_buffer_type = std::vector<unsigned_char_type>;

/* safe buffer does not allow mixing singed and unsigned char's */
static uc_buffer_type uc_buffer(safe_size  sz_) noexcept
{
	// Safe u char
	return uc_buffer_type( safe_size::value_type(sz_), unsigned_char_type::value_type(0) );
};

void test_comparators() 
{
	// Safe SiZE
	using safe_size = dbj::util::nothing_but < size_t >;

	safe_size s1{ size_t(1) };
	safe_size s2{ size_t(2) };

	SX(s1 < s2);

	// this should provoke a build warning
	// this is getting the data out 
	safe_size::value_type sze = s1;

	sze = 23.4 ;

	float  f{ float(1.2)  };
	double d{ double(3.4)  };

	SX(f < d);
}

void test_vector_walk() {

	// Safe SiZE
	using safe_size = dbj::util::nothing_but < size_t >;

	auto buffy_ = uc_buffer( safe_size::value_type(BUFSIZ) );

	for (safe_size walker = safe_size(safe_size::value_type(0)) ;
		walker < safe_size(buffy_.size()); 
		walker++
		) {
		// since this is safe buffer of u chars 
		// we need to take care so that we
		// pass u char and notthing but u char
		buffy_[walker] = unsigned_char_type::value_type('?') ;
	}

	SX( buffy_.data() );
}

/*
basic tests on type T
*/
template<typename T >
auto test_basic(void) -> dbj::util::nothing_but<T>
{
	/*
	Attention: T and dbj::remove_cvr_t<T>
	might be two different types
	do not mix them, use only one
	*/
	using TT = typename dbj::remove_cvr_t<T>;
	using NBT = dbj::util::nothing_but<TT>;

	TT value_{};

	// default ctor
	NBT nbt_a;
	NBT nbt_b(value_);
	// assignment
	nbt_a = mover(nbt_b);

	assert(!(nbt_a < nbt_b));

	// compare wrapped up to native T
	SX(nbt_a < nbt_b);
	SX(nbt_a == nbt_b);

	// notice the use of TT
	TT& peeping_tom = nbt_b.data();

	SX(nbt_b);
	return nbt_b;
}

void test_different_types()
{
	// fundamental types
	// no can do -- test_basic<void>();
	// no can do -- test_basic<std::nullptr_t>();
	// floating point types
	test_basic<float>();
	test_basic<double>();
	test_basic<long double>();
	// integral types
	test_basic<bool>();
	test_basic<char>();
	test_basic<signed char>();
	test_basic<unsigned char>();
	test_basic<char16_t>();
	test_basic<char32_t>();
	test_basic<wchar_t>();
	// signed integer types
	test_basic<short int>();
	test_basic<int>();
	test_basic<long int>();
	test_basic<long long int>();
	// unsigned integer types
	test_basic<unsigned short int>();
	test_basic<unsigned int>();
	test_basic<unsigned long int>();
	test_basic<unsigned long long int>();

}


/*
-----------------------------------------------------------------------------
try to trick with using two similar types
*/
void test_try_to_trick()
{
	/*
	NOTE: in here (MSVC  19.16.27027.1 for x86 )
	type of 2.3 is double
	type of float(2.3) is float
	type of 2.3f is float
	so to convince dbj::util::nothing_but<float>
	to play, please use float() c++ style cast
	or appropriate float literal operators
	as bellow

	(no suffix) defines double
	f F defines float
	l L defines long double

	*/
	using just_float = dbj::util::nothing_but<float>;
	using just_double = dbj::util::nothing_but<double>;

	auto just_float_fun = [](just_float  jf_arg)
		-> just_float
	{ return { 2.3f };  };

	auto just_double_fun = [](just_double jd_arg)
		-> just_double
	{ return { (2.3) }; };

	SX(typeid(2.3f).name());
	SX(typeid(float(2.3)).name());
	SX(typeid(42).name());

	// if no float() cast
	// 'argument': truncation from 'double' to 'T'
	just_float(2.3f);

	// if no float() cast 
	// 'argument': truncation from 'double' to 'T'
	just_float jf = 2.3f;
	just_float jf_aggregate = { 2.3f };

	just_double(2.3);
	just_double jd = 2.3;

	// no can do -- jf = jd;

	jf < jf;
	// no can do -- jf < jd;

	just_float_fun(jf);
	just_double_fun(jd);

}
/*
-----------------------------------------------------------------------------
*/
void test_assignments()
{
	using just_signed = dbj::util::nothing_but<signed char>;
	using just_unsigned = dbj::util::nothing_but<unsigned char>;

	just_signed s;
	just_unsigned u;

#ifndef _MSC_VER
	typedef unsigned char uint8_t;
	typedef signed char   int8_t;
#endif
	// CLANG/GNUC/G++/MSVC(UCRT) default behaviour is wrong
	// no warnings whatsoever here
	uint8_t uc = int8_t('s');
	int8_t sc = uc;

	s = int8_t('s');
	u = uint8_t('u');

	/*
	no can do:
	s = 's';
	u = 'u';
	s = u;
	s == u;
	*/
}
/*
-----------------------------------------------------------------------------
*/
template<typename T>
auto native_array_filler(T(&sarr_arg)[3])->T(&)[3]
{
	typedef T nb_t;
	typedef typename nb_t::value_type VT;

	sarr_arg[0] = nb_t(VT('9'));
	sarr_arg[1] = nb_t(VT('8'));
	sarr_arg[2] = nb_t(VT('7'));

	return sarr_arg;
};

template<typename T>
auto native_array_filler(T* (&sarr_arg)[3])->T* (&)[3]
{
	typedef T nb_t;
	typedef typename nb_t::value_type VT;

	sarr_arg[0] = &nb_t(VT('X'));
	sarr_arg[1] = &nb_t(VT('Y'));
	sarr_arg[2] = &nb_t(VT('Z'));

	return sarr_arg;
};

void test_compatibility()
{
	auto filler = [](auto sarr_arg)
	{
		using container = decltype(sarr_arg);
		using nothing_but = typename container::value_type;
		using v_type = typename nothing_but::value_type;

		sarr_arg[0] = nothing_but(v_type('A'));
		sarr_arg[1] = nothing_but(v_type('B'));
		sarr_arg[2] = nothing_but(v_type('C'));

		return sarr_arg;
	};

	auto display = [](auto arg_)
	{
		if constexpr (false == std::is_pointer< decltype(arg_[0]) >::value) {
			wprintf(L"\n\n%S\n\n{ %c %c %c }\n\n",
				typeid(arg_).name(),
				arg_[0].data(),
				arg_[1].data(),
				arg_[2].data()
			);
		}
		else {
			wprintf(L"\n\n%S\n\n{ %c %c %c }\n\n",
				typeid(arg_).name(),
				(arg_[0])->data(),
				(arg_[1])->data(),
				(arg_[2])->data()
			);
		}
	};

	using just_signed = dbj::util::nothing_but<signed char>;
	using just_unsigned = dbj::util::nothing_but<unsigned char>;

	// nothing happens implicitly in the world of nothing_but<T>
	just_signed	sarr[3];
	just_unsigned	uarr[3];

	display(native_array_filler(sarr));
	display(native_array_filler(uarr));

	just_signed* sparr[3];
	just_unsigned* uparr[3];

	//display(native_array_filler(sparr));
	// display(native_array_filler(uparr));

	// std::array perusal
	{
		std::vector<just_signed>	std_vec(3);
		std::array<just_signed, 3>	std_arr;

		display(filler(std_arr));
		display(filler(std_vec));
	}
}

#pragma warning( pop )
